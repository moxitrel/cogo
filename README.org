* Introduction
An asymmetric stackless coroutine library written in pure C for embedded programming inspired by Protothreads, which implemented yield, await, concurrency and channel.

* Advantages compared with other stackful coroutine libraries
- better portability
- unlimited recursion (avoid stack overflow) for coroutine

* Difference compared with Protothreads

* Overview
#+BEGIN_SRC C
#include "cogo/cogo_async.h"

CO_DECLARE(coroutine_name, T parameter, ...)
{
CO_BEGIN:

    //
    // user code
    //

CO_END:;
}
#+END_SRC

* Example
*** Natural number generator
#+BEGIN_SRC C
#include <stdio.h>
#include "cogo/cogo_async.h"

// CO_DECLARE(NAME, ...): declare a coroutine
// nat_gen: coroutine name
// value: save return value
CO_DECLARE(nat_generator, int value)
{
    // nat_generator_t: defined by CO_DECLARE() with pattern "NAME_t"
    // void* co_this: coroutine arguments
    nat_generator_t* const thiz = (nat_generator*)co_this;

CO_BEGIN: // mark coroutine begin

    // thiz->value: reference "value"
    for (thiz->value = 0; ; thiz->value++) {
        CO_YIELD; // return (next run start from here)
    }

CO_END: // mark coroutine end
    ;
}

void nat_generator_example(void)
{
    // make a coroutine instance
    nat_generator_t ng = CO_INITIALIZER(&ng, nat_generator, 0);

    // run coroutine until yield
    CO_RESUME(&ng);
    // ng.value: reference coroutine argument
    printf("ng.value: %d\n", ng.value);   // ng.value: 0

    // continue to run starting from last CO_YIELD
    CO_RESUME(&ng);
    printf("ng.value: %d\n", ng.value);   // ng.value: 1

    CO_RESUME(&ng);
    printf("ng.value: %d\n", ng.value);   // ng.value: 2
}
#+END_SRC

* See Also
- [[https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html][Coroutines in C]]
- [[http://dunkels.com/adam/pt/][Protothreads]]
