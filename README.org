* Introduction
A stackless coroutine library for C/C++, implemented yield, await, concurrency and channel.

* Features
- Easy to use
- Portable
- Fast
- Reenterable

* Overview
*** C
#+BEGIN_SRC C
#include "cogo.h"

typedef struct {
    co_t co_t;

    //
    // declare coroutine local variables, return values as struct filed
    //
} <T>;

void fun(<T> *co)
{
    co_begin(co);

    //
    // user code
    //

    co_end(co);
}
#+END_SRC

*** C++
#+BEGIN_SRC C++
#include "cogo.h"

class <T> : public co_t {
    //
    // declare local variables, return values as member variables.
    //

    void operator()()
    {
        co_begin();

        //
        // user codes
        //

        co_end();
    }
};
#+END_SRC

* Example
*** Natural Number Generator (C)
#+BEGIN_SRC C
#include "cogo.h"

typedef struct {
    co_t co_t;
                //
    int value;  // declare local variables and return values
                //
} nat_t;

void nat(nat_t *co)
{
    co_begin(co);
                                            //
    for (co->value = 0; ; co->value++) {    //
        co_yield(co);                       // user code
    }                                       //
                                            //
    co_end(co);
}

int main()
{
    nat_t n = {
        .co_t = CO(nat),
    };

    nat(&n);    // n.value: 0
    nat(&n);    // n.value: 1
    nat(&n);    // n.value: 2
}
#+END_SRC

*** Fibonacci Number (C++)
#+BEGIN_SRC C++
#include "cogo.h"

class Fibonacci : public co_t {
    unsigned int n;     // arg
    unsigned int v;     // return value
    Fibonacci *fib_n1;  // local variable, f(n-1)
    Fibonacci *fib_n2;  // local variable, f(n-2)

    void operator()()
    {
        co_begin();

        if (n == 0) {           // f(0) = 0
            v = 0;
        } else if (n == 1) {    // f(1) = 1
            v = 1;
        } else {                // f(n) = f(n-1) + f(n-2)
            fib_n1 = new Fibonacci(n - 1);
            fib_n2 = new Fibonacci(n - 2);

            co_await(fib_n1);   // call f(n-1)
            co_await(fib_n2);   // call f(n-2)
            v = fib_n1->value() + fib_n2->value();

            delete fib_n1;
            delete fib_n2;
        }

        co_end();
    }

public:
    Fibonacci(unsigned int n)
        : n(n)
    {}

    unsigned int value()
    {
        return v;
    }
};

int main()
{
    auto fib = Fibonacci(9);
    fib.run();
    fib.value();    // 34
}
#+END_SRC

* Getting Started
** Requirement
- C99
- C++11

*** C++
#+BEGIN_SRC C++
//
// 1. include header "cogo.h"
//
#include "cogo.h"
#include <stdio.h>

//
// 2. define a class that inherit co_t
//
class PrintN : public co_t {
    //
    // declare local variables, parameters, return values for coroutine function as member variables
    //
    int i;

    //
    // 3. override operator(), which has the type "void ()"
    //
    void operator()()
    {
        //
        // 4. set coroutine begin
        //
        co_begin();

        //
        // 5. user code (no local variable allowed, declare as member variable instead)
        //
        for (i = 0; i < 7; i++) {
            printf("%p:%d\n", this, i);
            co_yield();    // yield
        }

        //
        // 4. set coroutine end
        //
        co_end();
    }

    //
    // 6. define constructor if needed
    //
// public:
    // PrintN(...)
    // {
    //    ...
    // }
};

                                // 2. inherit co_t
class CoroutineExample : public co_t {
                                //
    PrintN coroutine1;          // declare local variables
    PrintN coroutine2;          //

    void operator()()           // 3. override operator()
    {
        co_begin();             // 4. coroutine begin

                                // 5. user code
        co_start(coroutine1);   // add coroutine1 to scheduler
        co_start(coroutine2);   // add coroutine2 to scheduler
                                //

        co_end();               // 4. coroutine end
    }

// public:
    // CoroutineExample(...)    // 6. define constructor if needed
    // {
    //    ...
    // }
};


int main()
{
    // Run until finish all coroutines.
    // Output:
    //  0x8f0:0
    //  0x8f0:1
    //  0x918:0
    //  0x8f0:2
    //  0x918:1
    //  0x8f0:3
    //  ...
    CoroutineExample().run();
}
#+END_SRC

*** C
#+BEGIN_SRC C
#include "cogo.h"           // 1. include header

typedef struct {            // 2. inherit co_t
    co_t co;                // put co_t in first

                            //
    int value;              // declare local variables, return values of coroutine function
                            //
} nat_gen_t;

void nat_gen(nat_gen_t *co) // 3. define coroutine function with the type "void (co_t *)"
{
    co_begin(co);           // 4. set Coroutine begin

                            // 5. user code
    for (co->value = 0; ; co->value++) {
        co_yield(co);       // yield
    }

    co_end(co);             // 4. set coroutine end
}
                            // 6. define constructor, init co_t member with CO()
#define NAT_GEN()   ((nat_gen_t){.co = CO(nat_gen),})


int main(void)
{
    nat_gen_t ng = NAT_GEN();

    nat_gen(&ng);           // ng.value = 0
    nat_gen(&ng);           // ng.value = 1
    nat_gen(&ng);           // ng.value = 2

    return 0;
}
#+END_SRC

* API
*** C++
- co_begin ()      :: Set coroutine begin.
                      List with the line numbers (__LINE__) of macros
                        *co_yield()*,
                        *co_return()*,
                        *co_await()*,
                        *co_start()*,
                        *co_wait()*,
                        *co_broadcast()*,
                      or omit if GNUC extension enabled.
- co_end   ()      :: Set coroutine end.
- co_yield ()      :: Yield.
- co_return()      :: Return with ending coroutine.
- co_await(co_t &) :: Await another coroutine to finish.
- co_start(co_t &) :: Add a coroutine to scheduler to run.
- co_wait     (co_blocking_t &) :: block current coroutine until notified.
- co_broadcast(co_blocking_t &) :: wake up all coroutines blocked by specified co_blocking_t.

- obj.run()   :: Run until all coroutines finished, with /obj/ as entry (like main()).
- obj.state() :: Return the current running state of coroutine /obj/.
  -  0: ready
  - >0: running
  - <0: stopped, coroutine is finished

*** C
- co_begin (co_t *)         :: Mark coroutine begin.
- co_end   (co_t *)         :: Mark coroutine end.
- co_yield (co_t *)         :: Yield from coroutine.
- co_return(co_t *)         :: Return with ending coroutine.
- co_await (co_t *, co_t *) :: Await another coroutine to finish.
- co_start (co_t *, co_t *) :: Add a coroutine to scheduler to run.

- co_run  (co_t *) :: loop running until finish all coroutines
+ co_state(co_t *) :: Return the current running state of coroutine /obj/.
  -  0: ready
  - >0: running
  - <0: stopped, coroutine is finished

* See Also
- [[https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html][Coroutines in C]]
- [[http://dunkels.com/adam/pt/][Protothreads]]    
