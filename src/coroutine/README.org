* INTRODUCTION
A stackless coroutine library written in pure C and C++.

* FEATURES
- Easy to use
- Portable
- Reenterable
- Small

* OVERVIEW
#+BEGIN_SRC C++
#include "coroutine.h"

class <T> : public co_t {
    //
    // Declare local variables, return values as member variables
    //

    void operator()()
    {
        co_begin(...);

        //
        // User codes
        //

        co_end();
    }
};
#+END_SRC

* EXAMPLE
#+BEGIN_SRC C++
#include "coroutine.h"

// Natural number generator
struct Nat : public co_t {
    unsigned int value;

    void operator()()
    {
        co_begin(12);

        for (value = 0; ; value++) {
            co_yield();
        }

        co_end();
    }
};

int main()
{
    Nat nat;
    nat(); // nat.value: 0
    nat(); // nat.value: 1
    nat(); // nat.value: 2
}
#+END_SRC

* Getting Started
*** C++
#+BEGIN_SRC C++
//
// 1. Include header "coroutine.h"
//
#include "coroutine.h"
#include <stdio.h>

//
// 2. Define a class that inherit co_t
//
class PrintN : public co_t {    // Print 0x7ffee80:0, 0x7ffee80:1, ... 0x7ffee80:6
    //
    // Declare local variables, parameters, return values for coroutine function
    //
    int i;

    //
    // 3. Override operator(), which has the type "void ()"
    //
    void operator()()
    {
        //
        // 4. Set coroutine begin
        //
        co_begin(32);       // 32: list line numbers of co_yield(), co_await(), co_sched(), i.e. the value of __LINE__
     // co_begin();         // you can omit line numbers if enable GNUC extension

        //
        // 5. User code (no local variable allowed, use member variable instead)
        //
        for (i = 0; i < 7; i++) {
            printf("%p:%d\n", this, i);
            co_yield();    // yield
        }

        //
        // 4. Set coroutine end
        //
        co_end();
    }

    //
    // 6. Define constructor if needed
    //
// public:
    // PrintN(...)
    // {
    //    ...
    // }
};

// 2. Define a class inherit co_t
class CoroutineExample : public co_t {
    PrintN coroutine1;          // Declare local variables of coroutine function
    PrintN coroutine2;          //

    void operator()()           // 3. Override operator()
    {
        co_begin(62,63);        // 4. Coroutine begin
     // co_begin();

                                // 5. User code
        co_sched(coroutine1);   // add coroutine1 to scheduler
        co_sched(coroutine2);   // add coroutine2 to scheduler

        co_end();               // 4. Coroutine end
    }

// public:                      // 6. Define constructor if needed
    // CoroutineExample(...)
    // {
    //    ...
    // }
};

// 7. Use it
int main()
{
    // Run until finish all coroutines.
    // Output:
    //  0x8f0:0
    //  0x8f0:1
    //  0x918:0
    //  0x8f0:2
    //  0x918:1
    //  0x8f0:3
    //  ...
    CoroutineExample().run();
}
#+END_SRC

*** C
#+BEGIN_SRC C
#include "coroutine.h"      // 1. Include header "coroutine.h"

// 2. Define a struct inherit co_t
typedef struct {
    co_t co;    // inherit co_t (as first field)

    // Declare local variables, return values of coroutine function
    int value;
} nat_gen_t;

void nat_gen(nat_gen_t *co) // 3. Define coroutine function with the type "void (co_t *)"
{
    co_begin(co, 18);       // 4. Set Coroutine begin
 // co_begin(co);           // you can omit line numbers if enable GNUC extension

    // 5. User code
    for (co->value = 0; ; co->value++) {
        co_yield(co);      // yield
    }

    co_end(co);             // 4. Set coroutine end
}
// 6. Define constructor, init co_t member with CO()
#define NAT_GEN()   ((nat_gen_t){.co = CO(nat_gen),})

// 7. Use it
int main(void)
{
    nat_gen_t ng = NAT_GEN();

    nat_gen(&ng);   // ng.value = 0
    nat_gen(&ng);   // ng.value = 1
    nat_gen(&ng);   // ng.value = 2

    return 0;
}
#+END_SRC

* API
*** C++
- co_begin (...)   :: Set coroutine begin.
                      List with the line numbers of *co_yield*, *co_await*, *co_sched*, *co_wait*, *co_broadcast*,
                      or omit if GNUC extension enabled.
- co_end  ()       :: Set coroutine end.
- co_yield()       :: Yield.
- co_return()      :: Return with coroutine finish.
- co_await(co_t &) :: Await a coroutine to finish.
- co_sched(co_t &) :: Add   a coroutine to current scheduler to run.
- co_wait     (co_blocking_t &) :: block current coroutine until notified.
- co_broadcast(co_blocking_t &) :: wake up all coroutines blocked by specified co_blocking_t.

- o.run()   :: Run until all coroutines finished, with o as entry.
- o.state() :: Return the running state of coroutine o.
  -  0: ready.
  - >0: running.
  - <0: stop, coroutine is finished.
*** C
- co_begin (co_t *, ...)    :: set coroutine begin
- co_end   (co_t *)         :: set coroutine end
- co_yield(co_t *)         :: yield
- co_await  (co_t *, co_t *) :: call another coroutine (block current coroutine)
- co_sched (co_t *, co_t *) :: add a coroutine to the scheduler to run

- co_run  (co_t *) :: loop running until finish all coroutines
- co_state(co_t *) :: return running state
                        0, ready
                       >0, running
                       <0, stop, coroutine is finished
* SEE ALSO
- Coroutines in C (https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html)
- Protothreads    (http://dunkels.com/adam/pt/)
