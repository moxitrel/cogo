* INTRODUCTION
A stackless coroutine library written in pure C and C++.

* FEATURES
- Portable: pure C/C++
- Reenterable
- Small

* Getting Start
*** C++
#+BEGIN_SRC C++
//
// 1. 包含头文件 "coroutine.h"
//
#include "coroutine.h"

#include <stdio.h>

//
// 2. 自定义协程类，必须继承 co_t
//
class PrintNat : public co_t {
    //
    // 定义 局部变量, 返回值, ...
    //
    int i;


    //
    // 3. 重载运算符operator(), 类型必须为 void()
    //
    void operator()()
    {
        //
        // 4. 标识 协程开始 (必须)
        //
        co_begin(21,24,...);    // 21,24,...: 列出所有 co_return(), co_call(), co_sched() 所在的行号, 即 __LINE__ 的值
     // co_begin();             // 若开启GNUC扩展，可省略行号

        //
        // 5. 用户代码 (*** 无法使用局部变量, 用 类成员变量替代 ***)
        //            (不要使用 return)
        //
        for (i = 0; i < 9; i++) {
            printf("%d\n", i);
            co_return();    // 返回，下次被调用，从此处开始执行
        }

        printf("%d\n", i);
        co_return();        // 返回，下次被调用，从此处开始执行


        //
        // 4. 标识 协程结束 (必须)
        //
        co_end();
    }
};

//
// 6. 使用
//
void example()
{
    PrintNat printNat;

    // Run until finish.
    // Print:
    //  0
    //  1
    //  2
    //  ...
    printNat.run();
}
#+END_SRC

*** C
#+BEGIN_SRC C
//
// 1. 包含头文件 "coroutine.h"
//
#include "coroutine.h"

#include <stdio.h>

//
// 2. 自定义协程结构，必须继承 co_t
//
typedef struct {
    //
    // 继承co_t (作为第1个字段)
    //
    co_t co;

    //
    // 定义 局部变量, 返回值, ...
    //
    int i;
} print_nat_t;

//
// 3. 定义协程函数, 类型必须为 void (co_t *)
//
void print_nat(print_nat_t *co)
{
    //
    // 4. 标识 协程开始 (必须)
    //
    co_begin(co, 21,24,...);    // 21,24,...: 列出所有 co_return(), co_call(), co_sched() 所在的行号, 即 __LINE__ 的值
 // co_begin(co);               // 若开启GNUC扩展，可省略行号

    //
    // 5. 用户代码 (*** 不要使用局部变量, 无法被恢复; 定义到 struct字段 中 ***)
    //            (不要使用 return)
    //
    for (co->i = 0; co->i < 9; co->i++) {
        printf("%d\n", co->i);
        co_return(co);          // 返回，下次被调用，从此处开始执行
    }

    printf("%d\n", co->i);
    co_return(co);              // 返回，下次被调用，从此处开始执行


    //
    // 4. 标识 协程结束 (必须)
    //
    co_end(co);
}

//
// 6. 使用
//
void example()
{
    // 7. 初始化 协程结构
    print_nat_t printNat = {
        .co = CO(print_nat),    // 初始化 co_t
    //  .i = ???,               // 忽略 i 的初始化
    };

    // Run until finish.
    // Print:
    //  0
    //  1
    //  2
    //  ...
    co_run((co_t *)&printNat);
}
#+END_SRC

* API
*** C++
- co_begin (...)    : coroutine begin
- co_end   ()       : coroutine end
- co_return()       : yield
- co_call  (co_t &) : call another coroutine (block current coroutine)
- co_sched (co_t &) : add a coroutine to the scheduler to run

- obj.state() : return running state
                 0, ready
                >0, running
                <0, stop, coroutine is finished
- obj.run()   : loop running until finish all coroutines

*** C
- co_begin (co_t *, ...)    : coroutine begin
- co_end   (co_t *)         : coroutine end
- co_return(co_t *)         : yield
- co_call  (co_t *, co_t *) : call another coroutine (block current coroutine)
- co_sched (co_t *, co_t *) : add a coroutine to the scheduler to run

- co_state(co_t *)  : return running state
                       0, ready
                      >0, running
                      <0, stop, coroutine is finished
- co_run(co_t *)    : loop running until finish all coroutines

* EXAMPLE
*** C++
#+BEGIN_SRC C++
#include "coroutine.h"      // 1. include coroutine.h
#include <stdio.h>

// A coroutine print 0x7ffee80:0, 0x7ffee80:1, ... 0x7ffee80:6
class Print: public co_t {  // 2. inherit co_t
    // define local variables for coroutine function
    int i;

    void operator()()       // 3. override operator(), which has the type "void ()"
    {
        co_begin(16);       // 4. coroutine begin, 16: the line number where co_return(), co_call(), co_sched() appear
     // co_begin();         //    you can omit line numbers if enable gnuc extension

        for (i = 0; i < 7; i++) {
            printf("%p:%d\n", this, i);
            co_return();    // 5. yield
        }

        co_end();           // 4. coroutine end
    }
};

// A coroutine create two Print coroutine which run concurrently.
class CoroutineExample : public co_t {  // inherit co_t
    // define local variables
    Print coroutine1;
    Print coroutine2;

    void operator()()           // override operator()
    {
        co_begin(34, 35);
     // co_begin();

        co_sched(coroutine1);   // run coroutine1 concurrently
        co_sched(coroutine2);   // run coroutine2 concurrently

        co_end();
    }
};

int main()
{
    // Run until finish all coroutines.
    // Print:
    //  0x8f0:0
    //  0x8f0:1
    //  0x918:0
    //  0x8f0:2
    //  0x918:1
    //  0x8f0:3
    //  ...
    CoroutineExample().run();
}
#+END_SRC

*** C
#+BEGIN_SRC C
#include "coroutine.h"  // 1. include coroutine.h
#include <stdio.h>

// a coroutine print 0x7ffee80:0, 0x7ffee80:1, ... 0x7ffee80:6
typedef struct {
    co_t co;            // 2. inherit co_t (as first field)
    int i;              // declare coroutine local variable as struct field
} co_print_t;

void co_print(co_print_t *co)   // 3. define coroutine function which has the type "void (co_t *)"
{
    co_begin(co, 17);   // 4. coroutine begin; 17: line number of co_return(), co_call(), co_sched()
 // co_begin(co);       //    you can omit line numbers if enable gnuc extension

    for (co->i = 0; co->i < 7; co->i++) {
        printf("%p:%d\n", co, co->i);
        co_return(co);  // 5. yield
    }

    co_end(co);         // 4. coroutine end
}
// co_print_t constructor
#define CO_PRINT() ((co_print_t){.co = CO(co_print),})


typedef struct {
    co_t co;                // inherit co_t
    co_print_t coroutine1;  // declare coroutine local variable
    co_print_t coroutine2;  // declare coroutine local variable
} coroutine_example_t;

// a coroutine run two co_print coroutine concurrently
void coroutine_example(coroutine_example_t *co) // define coroutine function
{
    co_begin(co, 37, 38);

    co_sched(co, &co->coroutine1);  // run coroutine1 concurrently
    co_sched(co, &co->coroutine2);  // run coroutine2 concurrently

    co_end(co);
}

// coroutine_example_t constructor
#define COROUTINE_EXAMPLE() ((coroutine_example_t){ \
    .co = CO(coroutine_example),                    \
    .coroutine1 = CO_PRINT(),                       \
    .coroutine2 = CO_PRINT(),                       \
})

int main()
{
    // Run until finish all coroutines.
    // Print:
    //  0x8f0:0
    //  0x8f0:1
    //  0x918:0
    //  0x8f0:2
    //  0x918:1
    //  0x8f0:3
    //  ...
    coroutine_example_t co = COROUTINE_EXAMPLE();
    co_run((co_t *)&co);
}
#+END_SRC

* SEE ALSO
- Coroutines in C (https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html)
- Protothreads    (http://dunkels.com/adam/pt/)
