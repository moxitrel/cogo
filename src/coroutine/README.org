* INTRODUCTION
A stackless coroutine library written in pure C and C++.

* FEATURES
- Portable: pure C/C++
- Reenterable
- Small

* Getting Start
*** C++
#+BEGIN_SRC C++
//
// 1. 包含头文件 "coroutine.h"
//
#include "coroutine.h"
#include <stdio.h>

//
// 2. 自定义协程类，必须继承 co_t
//
// 打印 0x7ffee80:0, 0x7ffee80:1, ... 0x7ffee80:6
class PrintN : public co_t {
    //
    // 定义协程函数的 局部变量, 参数, 返回值, ...
    //
    int i;


    //
    // 3. 重载运算符operator(), 类型必须为 void()
    //
    void operator()()
    {
        //
        // 4. 标识 协程开始
        //
        co_begin(35);       // 35: 列出所有 co_return(), co_call(), co_sched() 所在的行号, 即 __LINE__ 的值
     // co_begin();         // 若开启GNUC扩展，可省略行号

        //
        // 5. 用户代码 (*** 无法使用局部变量, 用 类成员变量替代 ***)
        //            (不要使用 return)
        //
        for (i = 0; i < 7; i++) {
            printf("%p:%d\n", this, i);
            co_return();    // 返回，下次被调用，从此处开始执行
        }

     // co_call(coroutine); // await, 调用其他协程直至完成
     // co_sched(coroutine);// 添加协程到调度器，并发运行

        //
        // 4. 标识 协程结束
        //
        co_end();
    }
};

//
// 2. 自定义协程类，必须继承 co_t
//
// 创建 2 个并发运行的 PrintN 协程
class CoroutineExample : public co_t {
    //
    // 定义协程函数的 局部变量, 参数, 返回值, ...
    //
    PrintN coroutine1;
    PrintN coroutine2;

    //
    // 3. 重载运算符operator(), 类型必须为 void()
    //
    void operator()()
    {
        //
        // 4. 标识 协程开始
        //
        co_begin(73,74);        // 73,74: 列出所有 co_return(), co_call(), co_sched() 所在的行号, 即 __LINE__ 的值
     // co_begin();             // you can omit line numbers if enable GNUC extension

        //
        // 5. 用户代码
        //
        co_sched(coroutine1);   // 添加 coroutine1 到调度器中运行
        co_sched(coroutine2);   // 添加 coroutine2 到调度器中运行

        //
        // 4. 标识 协程结束
        //
        co_end();
    }
};

// 6. 使用
int main()
{
    // 运行直至结束
    // 输出:
    //  0x8f0:0
    //  0x8f0:1
    //  0x918:0
    //  0x8f0:2
    //  0x918:1
    //  0x8f0:3
    //  ...
    CoroutineExample().run();
}

#+END_SRC

*** C
#+BEGIN_SRC C
//
// 1. 包含头文件 "coroutine.h"
//
#include "coroutine.h"

//
// 2. 自定义协程结构，必须继承 co_t
//
// 自然数生成器
typedef struct {
    //
    // 继承co_t (作为第1个字段)
    //
    co_t co;

    //
    // 声明协程函数的 局部变量, 参数, 返回值, ...
    //
    int value;  // 返回值
} nat_gen_t;

//
// 3. 定义协程函数, 类型必须为 void (co_t *)
//
// 自然数生成器
void nat_gen(nat_gen_t *co)
{
    //
    // 4. 标识 协程开始
    //
    co_begin(co, 38);           // 38, ...: 列出所有 co_return(), co_call(), co_sched() 所在的行号, 即 __LINE__ 的值
 // co_begin(co);               // 若开启GNUC扩展，可省略行号

    //
    // 5. 用户代码 (*** 不要使用局部变量, 无法被恢复; 定义到 struct 字段中 ***)
    //            (不要使用 return)
    //
    for (co->value = 0; ; co->value++) {
        co_return(co);          // 返回，下次被调用，从此处开始执行
    }

 // co_call(co, coroutine);     // await, 调用其他协程, 等待coroutine执行完毕
 // co_sched(co, coroutine);    // 添加协程到调度器，并发运行

    //
    // 4. 标识 协程结束
    //
    co_end(co);
}
// 6. 定义构造器, 用 CO() 初始化 co_t 成员
#define NAT_GEN()   ((nat_gen_t){.co = CO(nat_gen),})

// 7. 使用
int main(void)
{
    // 初始化
    nat_gen_t ng = NAT_GEN();

    nat_gen(&ng);   // ng.value = 0
    nat_gen(&ng);   // ng.value = 1
    nat_gen(&ng);   // ng.value = 2

    return 0;
}
#+END_SRC

* API
*** C++
- co_begin (...)    : coroutine begin
- co_end   ()       : coroutine end
- co_return()       : yield
- co_call  (co_t &) : call another coroutine (block current coroutine)
- co_sched (co_t &) : add a coroutine to the scheduler to run

- obj.state() : return running state
                 0, ready
                >0, running
                <0, stop, coroutine is finished
- obj.run()   : loop running until finish all coroutines

*** C
- co_begin (co_t *, ...)    : coroutine begin
- co_end   (co_t *)         : coroutine end
- co_return(co_t *)         : yield
- co_call  (co_t *, co_t *) : call another coroutine (block current coroutine)
- co_sched (co_t *, co_t *) : add a coroutine to the scheduler to run

- co_state(co_t *)  : return running state
                       0, ready
                      >0, running
                      <0, stop, coroutine is finished
- co_run(co_t *)    : loop running until finish all coroutines

* SEE ALSO
- Coroutines in C (https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html)
- Protothreads    (http://dunkels.com/adam/pt/)
