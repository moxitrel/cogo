---
# https://clang.llvm.org/docs/ClangFormatStyleOptions.html

# LK_None       (in configuration: None) Do not use.
# LK_Cpp        (in configuration: Cpp) Should be used for C, C++.
# LK_Java       (in configuration: Java) Should be used for Java.
# LK_JavaScript (in configuration: JavaScript) Should be used for JavaScript.
# LK_ObjC       (in configuration: ObjC) Should be used for Objective-C, Objective-C++.
# LK_Proto      (in configuration: Proto) Should be used for Protocol Buffers (https://developers.google.com/protocol-buffers/).
# LK_TableGen   (in configuration: TableGen) Should be used for TableGen code.
# LK_TextProto  (in configuration: TextProto) Should be used for Protocol Buffer messages in text format (https://developers.google.com/protocol-buffers/).
Language: Cpp

# LLVM     A style complying with the LLVM coding standards
# Google   A style complying with Google’s C++ style guide
# Chromium A style complying with Chromium’s style guide
# Mozilla  A style complying with Mozilla’s style guide
# WebKit   A style complying with WebKit’s style guide
# BasedOnStyle:  LLVM

# LS_Cpp03 (in configuration: Cpp03) Use C++03-compatible syntax.
# LS_Cpp11 (in configuration: Cpp11) Use features of C++11, C++14 and C++1z (e.g. A<A<int>> instead of A<A<int> >).
# LS_Auto (in configuration: Auto) Automatic detection based on the input.
Standard:        Cpp11

# Align      : someLongFunction(argument1,
#                               argument2);
#
# DontAlign  : someLongFunction(argument1,
#                  argument2);
#
# AlwaysBreak: someLongFunction(
#                  argument1, argument2);
#
AlignAfterOpenBracket: Align

# true:
# int aaaa        = 12;
# float b         = 23;
# std::string ccc = 23;
AlignConsecutiveAssignments: true

# true:
# int         aaaa = 12;
# float       b = 23;
# std::string ccc = 23;
AlignConsecutiveDeclarations: true

# DontAlign: #define A \
#             int aaaa; \
#             int b; \
#             int dddddddddd;
#
# Left     : #define A  \
#             int aaaa; \
#             int b;    \
#             int dddddddddd;
#
# Right    : #define A                                                        \
#             int aaaa;                                                       \
#             int b;                                                          \
#             int dddddddddd;
AlignEscapedNewlines: Left

# true: int aaa = bbbbbbbbbbbbbbb +
#                 ccccccccccccccc;
AlignOperands:   true

# true:                                   false:
# int a;     // My comment a      vs.     int a; // My comment a
# int b = 2; // comment  b                int b = 2; // comment about b
AlignTrailingComments: true

# true:
# void myFunction(
#   int a, int b, int c, int d, int e);
#
# false:
# void myFunction(int a,
#                 int b,
#                 int c,
#                 int d,
#                 int e);
AllowAllParametersOfDeclarationOnNextLine: true

# true: if (a) { return; }
AllowShortBlocksOnASingleLine: false

# true:                                   false:
# switch (a) {                    vs.     switch (a) {
# case 1: x = 1; break;                   case 1:
# case 2: return;                           x = 1;
# }                                         break;
#                                         case 2:
#                                           return;
#                                         }
AllowShortCaseLabelsOnASingleLine: true

# None      : Never merge functions
#
# Empty     : Only empty functions.
#             void f() {}
#
# InlineOnly: Only functions defined inside a class
#             class Foo {
#               void f() { foo(); }
#             };
#
# Inline    : Only functions defined inside a class. Implies “Empty”.
#             class Foo {
#               void f() { foo(); }
#             };
#             void f() {}
#
# All       : All functions fitting on a single line
AllowShortFunctionsOnASingleLine: Inline

# true: if (a) return;
AllowShortIfStatementsOnASingleLine: false

# true: while (true) continue;
AllowShortLoopsOnASingleLine: false

# true:
#  void f() {
#  f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,
#    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
#  }
#
# false:
#  void f() {
#  f(aaaaaaaaaaaaaaaaaaaa,
#    aaaaaaaaaaaaaaaaaaaa,
#    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
#  }
BinPackArguments: false

# true:
#  void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,
#         int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}
#
# false:
#  void f(int aaaaaaaaaaaaaaaaaaaa,
#         int aaaaaaaaaaaaaaaaaaaa,
#         int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}
BinPackParameters: false

# BS_Attach (in configuration: Attach) Always attach braces to surrounding context
#  try {
#    foo();
#  } catch () {
#  }
#  void foo() { bar(); }
#  class foo {};
#  if (foo()) {
#  } else {
#  }
#
#  enum X : int { A, B };
#
# BS_Linux (in configuration: Linux) Like Attach, but break before braces on function, namespace and class definitions
#  try {
#    foo();
#  } catch () {
#  }
#  void foo() { bar(); }
#  class foo
#  {
#  };
#  if (foo()) {
#  } else {
#  }
#  enum X : int { A, B };
#
# BS_Mozilla (in configuration: Mozilla) Like Attach, but break before braces on enum, function, and record definitions.
#  try {
#    foo();
#  } catch () {
#  }
#  void foo() { bar(); }
#  class foo
#  {
#  };
#  if (foo()) {
#  } else {
#  }
#  enum X : int { A, B };
#
# BS_Stroustrup (in configuration: Stroustrup) Like Attach, but break before function definitions, catch, and else.
#  try {
#    foo();
#  } catch () {
#  }
#  void foo() { bar(); }
#  class foo
#  {
#  };
#  if (foo()) {
#  } else {
#  }
#  enum X : int
#  {
#    A,
#    B
#  };
#
# BS_Allman (in configuration: Allman) Always break before braces.
#  try {
#    foo();
#  }
#  catch () {
#  }
#  void foo() { bar(); }
#  class foo {
#  };
#  if (foo()) {
#  }
#  else {
#  }
#  enum X : int { A, B };
#
# BS_GNU (in configuration: GNU)
#  try
#    {
#      foo();
#    }
#  catch ()
#    {
#    }
#  void foo() { bar(); }
#  class foo
#  {
#  };
#  if (foo())
#    {
#    }
#  else
#    {
#    }
#  enum X : int
#  {
#    A,
#    B
#  };
#
# BS_WebKit (in configuration: WebKit) Like Attach, but break before function
#  try {
#    foo();
#  } catch () {
#  }
#  void foo() { bar(); }
#  class foo {
#  };
#  if (foo()) {
#  } else {
#  }
#  enum X : int { A, B };
#
# BS_Custom (in configuration: Custom): use BraceWrapping
BreakBeforeBraces: Linux

BraceWrapping:
  # true:
  #  class foo {};
  #
  # false:
  #  class foo
  #  {};
  AfterClass: false

  # true:
  #  if (foo())
  #  {
  #    ;
  #  } else
  #  {
  #    ;
  #  }
  #  for (int i = 0; i < 10; ++i)
  #  {}
  #
  # false:
  #  if (foo()) {
  #    ;
  #  } else {
  #    ;
  #  }
  #  for (int i = 0; i < 10; ++i) {
  #    ;
  #  }
  AfterControlStatement: false

  # true:
  #  enum X : int
  #  {
  #    B
  #  };
  #
  # false:
  #  enum X : int { B };
  AfterEnum: true

  # true:
  #  void foo()
  #  {
  #    bar();
  #    bar2();
  #  }
  #
  # false:
  #  void foo() {
  #    bar();
  #    bar2();
  #  }
  AfterFunction: true

  # true:
  #  namespace
  #  {
  #    int foo();
  #    int bar();
  #  }
  #
  # false:
  #  namespace {
  #    int foo();
  #    int bar();
  #  }
  AfterNamespace:  true

  AfterObjCDeclaration: false

  # true:
  #  struct foo
  #  {
  #    int x;
  #  };
  #
  # false:
  #  struct foo {
  #    int x;
  #  };
  AfterStruct: true

  # true:
  #  union foo
  #  {
  #    int x;
  #  }
  #
  # false:
  #  union foo {
  #    int x;
  #  }
  AfterUnion: true

  # true:
  #  extern "C"
  #  {
  #    int foo();
  #  }
  #
  # false:
  #  extern "C" {
  #    int foo();
  #  }
  AfterExternBlock: true

  # true:
  #  try {
  #    foo();
  #  }
  #  catch () {
  #    ;
  #  }
  #
  # false:
  #  try {
  #    foo();
  #  } catch () {
  #    ;
  #  }
  BeforeCatch:     false

  # true:
  #  if (foo()) {
  #    ;
  #  }
  #  else {
  #    ;
  #  }
  #
  # false:
  #  if (foo()) {
  #    ;
  #  } else {
  #    ;
  #  }
  BeforeElse:      false

  IndentBraces:    false

  # true: require (AfterFunction:true) (AllowShortFunctionsOnASingleLine:None)
  #
  # false:           true:
  #  int f()   vs.    inf f()
  #  {}               {
  #                   }
  SplitEmptyFunction: false

  # true: require (AfterClass:true)
  #
  # false:            true:
  #  class Foo   vs.   class Foo
  #  {}                {
  #                    }
  SplitEmptyRecord: false

  # true: require (AfterNamespace:true)
  #
  # false:                true:
  #  namespace Foo   vs.   namespace Foo
  #  {}                    {
  #                        }
  SplitEmptyNamespace: false

# No:
#   template <typename T> T foo() {
#   }
#
#   template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,
#                               int bbbbbbbbbbbbbbbbbbbbb) {
#   }
#
# MultiLine:
#   template <typename T> T foo() {
#   }
#
#   template <typename T>
#   T foo(int aaaaaaaaaaaaaaaaaaaaa,
#         int bbbbbbbbbbbbbbbbbbbbb) {
#   }
#
# Yes:
#   template <typename T>
#   T foo() {
#   }
#
#   template <typename T>
#   T foo(int aaaaaaaaaaaaaaaaaaaaa,
#         int bbbbbbbbbbbbbbbbbbbbb) {
#   }
AlwaysBreakTemplateDeclarations: true

# true:                                  false:
# aaaa =                         vs.     aaaa = "bbbb"
#     "bbbb"                                    "cccc";
#     "cccc";
AlwaysBreakBeforeMultilineStrings: false

# None:
#   class A {
#     int f() { return 0; };
#   };
#   int f();
#   int f() { return 1; }
#
# All:
#   class A {
#     int
#     f() {
#       return 0;
#     };
#   };
#
#   int
#   f();
#
#   int
#   f() {
#     return 1;
#   }
#
# TopLevel:
#   class A {
#     int f() { return 0; };
#   };
#
#   int
#   f();
#
#   int
#   f() {
#     return 1;
#   }
#
# AllDefinitions:
#   class A {
#     int
#     f() {
#       return 0;
#     };
#   };
#
#   int f();
#
#   int
#   f() {
#     return 1;
#   }
#
# TopLevelDefinitions:
#   class A {
#     int f() { return 0; };
#   };
#
#   int f();
#
#   int
#   f() {
#     return 1;
#   }
AlwaysBreakAfterReturnType: None

# deprecated, backwards compatibility
AlwaysBreakAfterDefinitionReturnType: None

# BOS_None (in configuration: None): Break after operators
#  LooooooooooongType loooooooooooooooooooooongVariable =
#      someLooooooooooooooooongFunction();
#
#  bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +
#                       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==
#                   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
#               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >
#                   ccccccccccccccccccccccccccccccccccccccccc;
#
# BOS_NonAssignment (in configuration: NonAssignment): Break before operators that aren’t assignments
#  LooooooooooongType loooooooooooooooooooooongVariable =
#      someLooooooooooooooooongFunction();
#
#  bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                       + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                   == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#               && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      > ccccccccccccccccccccccccccccccccccccccccc;
#
# BOS_All (in configuration: All): Break before operators
#  LooooooooooongType loooooooooooooooooooooongVariable
#      = someLooooooooooooooooongFunction();
#
#  bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                       + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                   == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#               && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      > ccccccccccccccccccccccccccccccccccccccccc;
BreakBeforeBinaryOperators: All

# true:
#  veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription
#   ? firstValue
#   : SecondValueVeryVeryVeryVeryLong;
#
# false:
#  veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?
#   firstValue :
#   SecondValueVeryVeryVeryVeryLong;
BreakBeforeTernaryOperators: true

BreakBeforeInheritanceComma: true
# BILS_BeforeColon (in configuration: BeforeColon)
#  class Foo
#      : Base1,
#        Base2
#  {};
#
# BILS_BeforeComma (in configuration: BeforeComma)
#  class Foo
#      : Base1
#      , Base2
#  {};
#
# BILS_AfterColon (in configuration: AfterColon)
#  class Foo :
#      Base1,
#      Base2
#  {};
#BreakInheritanceList: BeforeComma

BreakConstructorInitializersBeforeComma: true
# BeforeColon:
#  Constructor()
#   : initializer1(),
#     initializer2()
#
# BeforeComma:
#  Constructor()
#   : initializer1()
#   , initializer2()
#
# AfterColon:
#  Constructor() :
#   initializer1(),
#   initializer2()
BreakConstructorInitializers: BeforeComma

# Allow breaking string literals when formatting
BreakStringLiterals: true

# 0: no limit, respect the input’s line breaking decisions within statements
ColumnLimit: 100

# regular expression, comment shouldn't be split into lines or otherwise changed
CommentPragmas:  '^ IWYU pragma:'

# true:
#  namespace Foo { namespace Bar {          namespace Foo { namespace Bar {
#  }}                                       namespace Extra {
#                                           }}}
# false:
#  namespace Foo {
#  namespace Bar {
#  }
#  }
CompactNamespaces: false

# true:
#  FitsOnOneLine::Constructor()
#      : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}
#
#  DoesntFit::Constructor()
#      : aaaaaaaaaaaaa(aaaaaaaaaaaaaa),
#        aaaaaaaaaaaaa(aaaaaaaaaaaaaa),
#        aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}
#
# false:
#  FitsOnOneLine::Constructor()
#      : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}
#
#  DoesntFit::Constructor()
#      : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),
#        aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}
ConstructorInitializerAllOnOneLineOrOnePerLine: true

# true:                                    false:
#  vector<int> x{1, 2, 3, 4};       vs.     vector<int> x{ 1, 2, 3, 4 };
#  vector<T>   x{{}, {}, {}, {}};           vector<T>   x{ {}, {}, {}, {} };
#  f(MyMap[{composite, key}]);              f(MyMap[{ composite, key }]);
#  new int[3]{1, 2, 3};                     new int[3]{ 1, 2, 3 };
Cpp11BracedListStyle: true

DerivePointerAlignment: false

# Disables formatting completely
DisableFormat:   false

##ExperimentalAutoDetectBinPacking: false

# true:                                  false:
#  namespace a {                  vs.     namespace a {
#   foo();                                 foo();
#  } // namespace a;                      }
FixNamespaceComments: true

# macros that should be interpreted as foreach loops instead of as function calls
ForEachMacros:   
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH

# IBS_Preserve (in configuration: Preserve):
#  #include "b.h"               into      #include "b.h"
#
#  #include <lib/main.h>                  #include "a.h"
#  #include "a.h"                         #include <lib/main.h>
#
# IBS_Merge (in configuration: Merge):
#  #include "b.h"               into      #include "a.h"
#                                         #include "b.h"
#  #include <lib/main.h>                  #include <lib/main.h>
#  #include "a.h"
#
# IBS_Regroup (in configuration: Regroup):
#  #include "b.h"               into      #include "a.h"
#                                         #include "b.h"
#  #include <lib/main.h>
#  #include "a.h"                         #include <lib/main.h>
IncludeBlocks:   Merge

# Regular expressions denoting the different #include categories used for ordering #includes.
# POSIX extended regular expressions are supported.
IncludeCategories: 
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        2
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        3
  - Regex:           '.*'
    Priority:        1

IncludeIsMainRegex: '(Test)?$'

# false:                                 true:
#  switch (fool) {                vs.     switch (fool) {
#  case 1:                                  case 1:
#    bar();                                   bar();
#    break;                                   break;
#  default:                                 default:
#    plop();                                  plop();
#  }                                      }
IndentCaseLabels: false

# PPDIS_None (in configuration: None) Does not indent any directives.
#  #if FOO
#  #if BAR
#  #include <foo>
#  #endif
#  #endif
#
# PPDIS_AfterHash (in configuration: AfterHash) Indents directives after the hash
#  #if FOO
#  #  if BAR
#  #    include <foo>
#  #  endif
#  #endif
IndentPPDirectives: AfterHash

# The number of columns to use for indentation
# 3:
#  void f() {
#     someFunction();
#     if (true, false) {
#        f();
#     }
#  }
IndentWidth:     4

# public、private 等的偏移, -IndentWidth
AccessModifierOffset: -4

# indentation of constructor initializer lists as well as inheritance lists.
ConstructorInitializerIndentWidth: 4

# 2:
# int i =         // VeryVeryVeryVeryVeryLongComment
#   longFunction( // Again a long comment
#     arg);
ContinuationIndentWidth: 4

# true:
#  LoooooooooooooooooooooooooooooooooooooooongReturnType
#      LoooooooooooooooooooooooooooooooongFunctionDeclaration();
#
# false:
#  LoooooooooooooooooooooooooooooooooooooooongReturnType
#  LoooooooooooooooooooooooooooooooongFunctionDeclaration();
IndentWrappedFunctionNames: false

# true:                                  false:
#  if (foo) {                     vs.     if (foo) {
#                                           bar();
#    bar();                               }
#  }
KeepEmptyLinesAtTheStartOfBlocks: false

# A regular expression matching macros that start a block and end a block
#With:
# MacroBlockBegin: "^NS_MAP_BEGIN|NS_TABLE_HEAD$"
# MacroBlockEnd: "^NS_MAP_END|\
# NS_TABLE_.*_END$"
#
# NS_MAP_BEGIN
#   foo();
# NS_MAP_END
#
# NS_TABLE_HEAD
#   bar();
# NS_TABLE_FOO_END
#
#Without:
# NS_MAP_BEGIN
# foo();
# NS_MAP_END
#
# NS_TABLE_HEAD
# bar();
# NS_TABLE_FOO_END
MacroBlockBegin: ''
MacroBlockEnd:   ''

# MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0
#  int f() {                              int f() {
#    int = 1;                                 int i = 1;
#                                             i = foo();
#    i = foo();                               return i;
#                                         }
#    return i;
#  }
MaxEmptyLinesToKeep: 1

# NI_None (in configuration: None) :
# namespace out {
# int i;
# namespace in {
# int i;
# }
# }
#
# NI_Inner (in configuration: Inner):
# namespace out {
# int i;
# namespace in {
#   int i;
# }
# }
#
# NI_All (in configuration: All):
# namespace out {
#   int i;
#   namespace in {
#     int i;
#   }
# }
NamespaceIndentation: None

PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 60

# PAS_Left (in configuration: Left) 
# int* a;
#
# PAS_Right (in configuration: Right) 
# int *a;
#
# PAS_Middle (in configuration: Middle)
# int * a;
PointerAlignment: Right

# false:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */
#
# true:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
# // information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
#  * information */
ReflowComments:  true

# false:                                 true:
# #include "b.h"                 vs.     #include "a.h"
# #include "a.h"                         #include "b.h"
SortIncludes:    true

# false:                                 true:
# using std::cout;               vs.     using std::cin;
# using std::cin;                        using std::cout;
SortUsingDeclarations: true

# true:                                  false:
# (int) i;                       vs.     (int)i;
SpaceAfterCStyleCast: false

# true:                                  false:
# template <int> void foo();     vs.     template<int> void foo();
SpaceAfterTemplateKeyword: false

# true:                                  false:
# int a = 5;                     vs.     int a=5;
# a += 42                                a+=42;
SpaceBeforeAssignmentOperators: true

# true:                                  false:
# Foo foo { bar };               vs.     Foo foo{ bar };
# Foo {};                                Foo{};
# vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };
# new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };
#SpaceBeforeCpp11BracedList: false

# true:                                  false:
# Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}
SpaceBeforeCtorInitializerColon: true

# true:                                  false:
# class Foo : Bar {}             vs.     class Foo: Bar {}
SpaceBeforeInheritanceColon: true

# put a space before opening parentheses
# SBPO_Never (in configuration: Never):
# void f() {
#   if(true) {
#     f();
#   }
# }
#
# SBPO_ControlStatements (in configuration: ControlStatements)
# void f() {
#   if (true) {
#     f();
#   }
# }
#
# SBPO_Always (in configuration: Always) 
# void f () {
#   if (true) {
#     f ();
#   }
# }
SpaceBeforeParens: ControlStatements

# true:                                  false:
# for (auto v : values) {}       vs.     for(auto v: values) {}
SpaceBeforeRangeBasedForLoopColon: false

# true:                                false:
# void f( ) {                    vs.   void f() {
#   int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};
#   if (true) {                          if (true) {
#     f( );                                f();
#   }                                    }
# }                                    }
SpaceInEmptyParentheses: false

# This does not affect trailing block comments (/* - comments)
# 3:
# void f() {
#   if (true) {   // foo1
#     f();        // bar
#   }             // foo
# }
SpacesBeforeTrailingComments: 1

# true:                                  false:
# static_cast< int >(arg);       vs.     static_cast<int>(arg);
# std::function< void(int) > fct;        std::function<void(int)> fct;
SpacesInAngles:  false

# true:                                  false:
# var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];
# f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});
SpacesInContainerLiterals: false

# true:                                  false:
# x = ( int32 )y                 vs.     x = (int32)y
SpacesInCStyleCastParentheses: false

# true:                                  false:
# t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;
SpacesInParentheses: false

# true:                                  false:
# int a[ 5 ];                    vs.     int a[5];
# std::unique_ptr<int[]> foo() {} // Won't be affected
SpacesInSquareBrackets: false

# UT_Never          (in configuration: Never) Never use tab.
# UT_ForIndentation (in configuration: ForIndentation) Use tabs only for indentation.
# UT_ForContinuationAndIndentation
#                   (in configuration: ForContinuationAndIndentation) Use tabs only for line continuation and indentation.
# UT_Always         (in configuration: Always) Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one.
UseTab:          Never
TabWidth:        8

# true:                                  false:
#  @Partial                       vs.     @Partial @Mock DataLoad loader;
#  @Mock
#  DataLoad loader;
BreakAfterJavaFieldAnnotations: true

# JSQS_Leave (in configuration: Leave)
#  string1 = "foo";
#  string2 = 'bar';
# JSQS_Single (in configuration: Single)
#  string1 = 'foo';
#  string2 = 'bar';
# JSQS_Double (in configuration: Double) 
#  string1 = "foo";
#  string2 = "bar";
JavaScriptQuotes: Leave

JavaScriptWrapImports: true
ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 2
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
...

